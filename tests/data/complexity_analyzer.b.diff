--- a/complexity_analyzer.py
+++ b/complexity_analyzer.py
@@ -3,6 +3,7 @@ import argparse
 import ast
 import sys
 from dataclasses import dataclass, field
+from collections import defaultdict
 from typing import List, Dict, Optional, Any
 from pathlib import Path
 from colorama import init, Fore, Style
@@ -41,11 +42,31 @@ class Complexity:
         
         # Don't add O(1) unless both are O(1)
         if self.expression == "O(1)" and other.expression == "O(1)":
-            expr = "O(1)"
+            expr = "O(2)"
         elif self.expression == "O(1)":
             expr = other.expression
         elif other.expression == "O(1)":
             expr = self.expression
+        elif self.expression == other.expression:
+            # Same complexity - combine coefficients
+            if self.expression == "O(n)":
+                expr = "O(2n)"
+            elif "O(" in self.expression and "n)" in self.expression:
+                # Extract coefficient
+                import re
+                match = re.match(r'O\((\d*)n\)', self.expression)
+                if match:
+                    coef = int(match.group(1)) if match.group(1) else 1
+                    expr = f"O({coef*2}n)"
+                else:
+                    expr = f"{self.expression}+{other.expression}"
+            else:
+                expr = f"{self.expression}+{other.expression}"
+        elif "O(" in self.expression and "O(" in other.expression:
+            # Try to combine similar terms
+            expr = self._combine_similar_terms(self.expression, other.expression)
+            if not expr:
+                expr = f"{self.expression}+{other.expression}"
         else:
             expr = f"{self.expression}+{other.expression}"
         
@@ -84,6 +105,43 @@ class Complexity:
         else:
             return other
     
+    def _combine_similar_terms(self, expr1: str, expr2: str) -> Optional[str]:
+        """Combine similar complexity terms with coefficients"""
+        import re
+        
+        # Parse expressions into a dict of complexity -> coefficient
+        terms = defaultdict(int)
+        
+        for expr in [expr1, expr2]:
+            # Split by + if present
+            parts = expr.split('+') if '+' in expr else [expr]
+            for part in parts:
+                part = part.strip()
+                if part == "O(1)":
+                    terms["1"] += 1
+                elif part == "O(n)":
+                    terms["n"] += 1
+                elif match := re.match(r'O\((\d+)\)', part):
+                    terms["1"] += int(match.group(1))
+                elif match := re.match(r'O\((\d*)n\)', part):
+                    coef = int(match.group(1)) if match.group(1) else 1
+                    terms["n"] += coef
+                elif "n*log(n)" in part:
+                    terms["n*log(n)"] += 1
+                elif "n²" in part:
+                    terms["n²"] += 1
+                elif "n³" in part:
+                    terms["n³"] += 1
+                else:
+                    return None  # Can't parse, return None
+        
+        # Build result
+        result_parts = []
+        for complexity in ["n³", "n²", "n*log(n)", "n", "1"]:
+            if complexity in terms and terms[complexity] > 0:
+                coef = terms[complexity]
+                result_parts.append(f"O({coef if coef > 1 else ''}{complexity})")
+        
+        return "+".join(result_parts) if result_parts else None
+    
     def _get_weight(self) -> int:
         """Get a rough weight for complexity comparison"""
         expr = self.expression
@@ -105,51 +163,86 @@ class Complexity:
         """Simplify the complexity expression WITHOUT reducing to dominant term"""
         expr = self.expression
         
-        # Handle nested multiplications (convert to exponents)
+        # First handle nested multiplications (convert to exponents)
         if '*' in expr:
-            parts = []
-            current = ""
-            depth = 0
-            
-            for char in expr:
-                if char == '(':
-                    depth += 1
-                    current += char
-                elif char == ')':
-                    depth -= 1
-                    current += char
-                elif char == '*' and depth == 0:
-                    parts.append(current)
-                    current = ""
-                else:
-                    current += char
-            
-            if current:
-                parts.append(current)
+            expr = self._simplify_multiplications(expr)
+        
+        # Then combine similar terms in additions
+        if '+' in expr:
+            expr = self._combine_additions(expr)
+        
+        # Clean up constants
+        if expr == "O(0)" or not expr:
+            expr = "O(1)"
+        
+        return Complexity(expr, self.is_approximate, self.details)
+    
+    def _simplify_multiplications(self, expr: str) -> str:
+        """Simplify multiplication expressions"""
+        import re
+        
+        # Handle O(n²)*O(n²) -> O(n⁴) etc
+        if "O(n²)*O(n²)" in expr:
+            expr = expr.replace("O(n²)*O(n²)", "O(n⁴)")
+        if "O(n³)*O(n)" in expr or "O(n)*O(n³)" in expr:
+            expr = expr.replace("O(n³)*O(n)", "O(n⁴)")
+            expr = expr.replace("O(n)*O(n³)", "O(n⁴)")
+        if "O(n²)*O(n)" in expr or "O(n)*O(n²)" in expr:
+            expr = expr.replace("O(n²)*O(n)", "O(n³)")
+            expr = expr.replace("O(n)*O(n²)", "O(n³)")
+        
+        # Count O(n) multiplications
+        n_count = expr.count("O(n)*O(n)")
+        if n_count > 0:
+            power_notation = {1: "²", 2: "⁴"}
+            if n_count in power_notation:
+                expr = expr.replace("O(n)*O(n)", f"O(n{power_notation[n_count]})", 1)
             
-            # Count O(n) occurrences
-            n_count = sum(1 for p in parts if p == "O(n)")
-            other_parts = [p for p in parts if p != "O(n)" and p != "O(1)"]
+        # Count individual O(n) terms being multiplied
+        parts = []
+        current = ""
+        depth = 0
+        
+        for char in expr:
+            if char == '(':
+                depth += 1
+                current += char
+            elif char == ')':
+                depth -= 1
+                current += char
+            elif char == '*' and depth == 0:
+                parts.append(current)
+                current = ""
+            else:
+                current += char
+        
+        if current:
+            parts.append(current)
+        
+        # Count O(n) occurrences
+        n_count = sum(1 for p in parts if p == "O(n)")
+        other_parts = [p for p in parts if p != "O(n)" and p != "O(1)"]
+        
+        if n_count >= 2:
+            power_notation = {2: "²", 3: "³", 4: "⁴"}
+            if n_count in power_notation:
+                result = f"O(n{power_notation[n_count]})"
+            else:
+                result = f"O(n^{n_count})"
             
-            if n_count >= 2:
-                power_notation = {2: "²", 3: "³", 4: "⁴"}
-                if n_count in power_notation:
-                    result = f"O(n{power_notation[n_count]})"
-                else:
-                    result = f"O(n^{n_count})"
-                
-                # Add other multiplicative factors
-                for part in other_parts:
-                    if "log" in part:
-                        result = result.replace(")", "*log(n))")
-                    elif part and part != "O(1)":
-                        result = f"{result}*{part}"
-                
-                expr = result
-            elif n_count == 1:
-                # Single O(n) with other factors
-                result = "O(n)"
-                for part in other_parts:
-                    if "log" in part:
-                        result = "O(n*log(n))"
+            # Add other multiplicative factors
+            for part in other_parts:
+                if "log" in part:
+                    result = result.replace(")", "*log(n))")
+                elif part and part != "O(1)":
+                    result = f"{result}*{part}"
+            
+            expr = result
+        elif n_count == 1:
+            # Single O(n) with other factors
+            result = "O(n)"
+            for part in other_parts:
+                if "log" in part:
+                    result = "O(n*log(n))"
+                elif part and part != "O(1)":
+                    result = f"{result}*{part}"
+            expr = result
+        
+        return expr
+    
+    def _combine_additions(self, expr: str) -> str:
+        """Combine similar terms in additions"""
+        import re
+        
+        parts = expr.split('+')
+        terms = defaultdict(int)
+        
+        for part in parts:
+            part = part.strip()
+            if part == "O(1)":
+                terms["1"] += 1
+            elif match := re.match(r'O\((\d+)\)', part):
+                terms["1"] += int(match.group(1))
+            elif part == "O(n)":
+                terms["n"] += 1
+            elif match := re.match(r'O\((\d+)n\)', part):
+                terms["n"] += int(match.group(1))
+            elif "n*log(n)" in part:
+                terms["n*log(n)"] += 1
+            elif "log(n)" in part and "n*" not in part:
+                terms["log(n)"] += 1
+            elif "n²" in part or "n^2" in part:
+                terms["n²"] += 1
+            elif "n³" in part or "n^3" in part:
+                terms["n³"] += 1
+            elif "n⁴" in part or "n^4" in part:
+                terms["n⁴"] += 1
+            else:
+                # Unknown term, keep as-is
+                if part and part != "O(1)":
+                    terms[part] = 1
+        
+        # Build result with proper ordering
+        result_parts = []
+        order = ["n⁴", "n³", "n²", "n*log(n)", "n", "log(n)", "1"]
+        
+        for complexity in order:
+            if complexity in terms and terms[complexity] > 0:
+                count = terms[complexity]
+                if complexity == "1":
+                    if count == 1:
+                        result_parts.append("O(1)")
                     elif part and part != "O(1)":
-                        result = f"{result}*{part}"
-                expr = result
+                        result_parts.append(f"O({count})")
+                elif complexity == "n":
+                    if count == 1:
+                        result_parts.append("O(n)")
+                    else:
+                        result_parts.append(f"O({count}n)")
+                else:
+                    if count == 1:
+                        result_parts.append(f"O({complexity})")
+                    else:
+                        # For higher order terms, we don't usually show coefficient
+                        # but we could if needed
+                        result_parts.append(f"O({complexity})")
         
-        # Clean up redundant O(1) in additions, but keep all other terms
-        if '+' in expr:
-            parts = expr.split('+')
-            # Remove O(1) only if there are other non-constant terms
-            non_constant = [p for p in parts if p != "O(1)"]
-            if non_constant:
-                expr = '+'.join(non_constant)
-            else:
-                expr = "O(1)"
+        # Add any unknown terms
+        for term, count in terms.items():
+            if term not in order and count > 0:
+                result_parts.append(term)
         
-        # If empty, return O(1)
-        if not expr:
-            expr = "O(1)"
+        # Remove O(1) terms if there are higher order terms
+        if len(result_parts) > 1:
+            result_parts = [p for p in result_parts if not (p == "O(1)" or re.match(r'O\(\d+\)', p))]
+            # Actually, keep constant terms as per requirement
+            # Revert this filtering
+            result_parts = []
+            for complexity in order:
+                if complexity in terms and terms[complexity] > 0:
+                    count = terms[complexity]
+                    if complexity == "1":
+                        if count == 1:
+                            result_parts.append("1")
+                        else:
+                            result_parts.append(str(count))
+                    elif complexity == "n":
+                        if count == 1:
+                            result_parts.append("n")
+                        else:
+                            result_parts.append(f"{count}n")
+                    else:
+                        if count == 1:
+                            result_parts.append(complexity)
+                        else:
+                            # For polynomial terms, coefficient usually not shown
+                            result_parts.append(complexity)
         
-        return Complexity(expr, self.is_approximate, self.details)
+        if result_parts:
+            return "O(" + " + ".join(result_parts) + ")"
+        else:
+            return "O(1)"
 
 @dataclass
 class AntiPattern:
@@ -259,6 +352,23 @@ class Analyzer(ast.NodeVisitor):
                     self.variable_types.insert(arg.arg, arg.annotation.id)
         
         # Analyze function body
@@ -280,6 +390,16 @@ class Analyzer(ast.NodeVisitor):
         """Analyze a list of statements"""
         total = Complexity.constant()
         
+        # Track variable assignments for type inference
+        for stmt in body:
+            if isinstance(stmt, ast.Assign):
+                if isinstance(stmt.value, ast.Call):
+                    if isinstance(stmt.value.func, ast.Name):
+                        if stmt.value.func.id == 'set':
+                            # Variable is assigned a set
+                            for target in stmt.targets:
+                                if isinstance(target, ast.Name):
+                                    self.variable_types[target.id] = 'set'
+                        elif stmt.value.func.id == 'list':
+                            for target in stmt.targets:
+                                if isinstance(target, ast.Name):
+                                    self.variable_types[target.id] = 'list'
+        
         for stmt in body:
             stmt_complexity = self.analyze_statement(stmt)
             total = total.combine_sequential(stmt_complexity)
@@ -439,9 +559,10 @@ class Analyzer(ast.NodeVisitor):
                     # Already in call stack - check depth
                     depth = self.call_stack.count(func_name)
                     if depth >= self.max_call_depth:
-                        complexity = Complexity.approximate("O(?)")
-                        complexity.with_detail(f"max recursion depth {self.max_call_depth} reached for {func_name}")
+                        known_complexity = self.functions.get(func_name, Complexity.approximate("O(?)"))
+                        complexity = Complexity.approximate(f"at least {known_complexity.expression}")
+                        complexity.with_detail(f"(maximum recursion depth {self.max_call_depth} reached)")
                     else:
                         # Allow the recursive call but track it
                         self.call_stack.append(func_name)
